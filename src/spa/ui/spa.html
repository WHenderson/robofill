<div ref:root class="ui padded container">
    <h1 class="ui dividing header">RoboFill</h1>

    <div ref:tabs class="ui top attached tabular menu">
        <a class="item active" data-tab="select">Select</a>
        <a class="item" data-tab="upload">Upload</a>
        <a class="item" data-tab="edit">Create / Edit</a>
    </div>

    <div class="ui bottom attached tab segment active" data-tab="select">
        <form class="ui form">
            <div class="field">
                <label>Select Script</label>
                <div ref:script class="ui fluid search selection dropdown">
                    <input type="hidden" name="country">
                    <i class="dropdown icon"></i>
                    <div class="default text">Select Script</div>
                    <div class="menu">
                        {{#each scripts as script, iscript}}
                        <div class="item" data-value="{{iscript}}" data-text="{{script.name}}">
                            <ScriptCard :script/>
                        </div>
                        {{/each}}
                    </div>
                </div>
            </div>

            {{#if scriptSelect}}
            <div class="ui raised segment">
                <ScriptCard script="{{scriptSelect}}" />
            </div>

            <div class="ui positive right floated button">
                <i class="play icon"></i>
                Execute
            </div>

            <div class="ui negative button" on:click="onDelScript(event, scriptSelect)">
                <i class="trash icon"></i>
                Delete
            </div>
            <div class="ui button" on:click="onScriptClone(event, scriptSelect)">
                <i class="clone icon"></i>
                Clone
            </div>
            <div class="ui button" on:click="onScriptEdit(event, scriptSelect)">
                <i class="edit icon"></i>
                Edit
            </div>

            {{/if}}
        </form>
    </div>
    <div class="ui bottom attached tab segment" data-tab="upload">
        <form class="ui {{uploadError ? 'error' : ''}} form">
            <div class="field">
                <label for="upload">Upload Script:</label>
                <div class="ui fluid file input action">
                    <input ref:uploadText type="text" readonly on:click="onUploadScript(event)">
                    <input ref:uploadFile type="file" id="upload" name="files1" autocomplete="off" style="display:none" on:change="onUploadScriptSelected(event)">
                    <div class="ui button" on:click="onUploadScript(event)">
                        Select...
                    </div>
                </div>
            </div>

            {{#if uploadError}}
            <div class="ui error message">
                <div class="header">Unable to read file</div>
                <p>{{uploadError}}</p>
            </div>
            {{/if}}

            {{#if scriptUpload}}
            <div class="ui raised segment">
                <ScriptCard script="{{scriptUpload}}"/>
            </div>

            <div class="ui primary right floated button">
                <i class="save icon"></i>
                Save
            </div>

            <div class="ui button">
                <i class="edit icon"></i>
                Edit
            </div>

            {{/if}}
        </form>
    </div>
    <div class="ui bottom attached tab segment" data-tab="edit">
        <ScriptEdit
                ref:scriptEdit
                script="{{scriptEdit || {}}}"

                on:save="onEditSave(event)"
                on:clone="onEditClone(event)"
                on:new="onEditNew(event)"
                on:delete="onEditDelete(event)"
            />
    </div>
</div>

<style>
</style>

<script>
    import Postmate from 'postmate';
    import ScriptCard from './script-card.html'
    import ScriptEdit from './script-edit.html'

    export default {
        setup(AutoFill) {
        },
        data() {
            return {
                scripts: [
                    {
                        name: 'my name',
                        author: 'my author',
                        description: 'my description xxx',
                        stamp: (new Date()).toISOString(),
                        scriptItems: [
                            {
                                type: 'set value',
                                selector: '#Q1',
                                data: 'my text val',
                                enabled: true
                            },
                            {
                                type: 'set value',
                                selector: '#Q2',
                                data: 'my other text val',
                                enabled: false
                            }

                        ]
                    },
                    { name: 'my lname', author: 'my mauthor', description: 'my ndescription zzz', stamp: (new Date()).toISOString() }
                ],
                scriptSelect: undefined, // script currently selected
                scriptUpload: undefined, // script being uploaded
                scriptEdit: undefined, // script being edited
                editOverwrite: undefined, // script being overwritten (when saved)
                uploadError: undefined // error during upload
            }
        },
        computed: {
        },
        oncreate() {
            // Initialise cross-frame communication
            const handshake = new Postmate.Model({
                height: () => document.height || document.body.offsetHeight
            });
            this.set({ handshake });

            handshake.then((parent) => {
                this.set({ parent });

                parent.emit('some-event', 'Woot Woot');
            });

            // Initialise tabs
            $(this.refs.tabs).find('.item')
                .tab();

            // Initialise script selection dropdown
            $(this.refs.script).dropdown({
                fullTextSearch: true,
                ignoreCase: true,
                match: 'text',
                onChange: (iscript, text, $choice) => {
                    iscript = parseInt(iscript, 10);

                    const scripts = this.get('scripts');
                    const scriptSelect = (iscript >= 0 && iscript < scripts.length) ? scripts[iscript] : undefined;
                    this.set({ scriptSelect });
                }
            });
            this.observe('scriptSelect', (scriptSelect) => {
                const index = this.get('scripts').indexOf(scriptSelect);
                if (index === -1)
                    $(this.refs.script).dropdown('clear');
                else
                    $(this.refs.script).dropdown('set selected', `${index}`);

                $(this.refs.script).dropdown('refresh');
            }, { defer: true });
            this.observe('scripts', (scripts) => {
                const index = scripts.indexOf(this.get('scriptSelect'));
                if (index === -1)
                    this.set({ scriptSelect: undefined });
            });
            this.observe('scripts', (scripts) => {
                const index = scripts.indexOf(this.get('scriptSelect'));
                if (index === -1) {
                    $(this.refs.script).dropdown('clear');
                }
                else
                    $(this.refs.script).dropdown('set selected', `${index}`);

                $(this.refs.script).dropdown('refresh');
            }, { defer: true });

            this.set({ scriptSelect: this.get('scripts')[0] });

        },
        ondestroy() {
        },
        methods: {
            onDelScript(event, script) {
                event.preventDefault();

                this.set({
                    scripts: this.get('scripts').filter(s => s !== script),
                    script: undefined
                });
            },
            onUploadScript(event, script) {
                event.preventDefault();

                $(this.refs.uploadFile).click();
            },
            onUploadScriptSelected(event, script) {
                if (event.target.files && event.target.files.length === 1) {
                    this.set({
                        scriptUpload: undefined,
                        uploadError: undefined
                    });

                    const file = event.target.files[0];

                    $(this.refs.uploadText).val(file.name);

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            this.set({
                                scriptUpload: JSON.parse(event.target.result),
                                uploadError: undefined
                            });
                        }
                        catch (e) {
                            this.set({
                                scriptUpload: undefined,
                                uploadError: e.message
                            });
                        }
                    };
                    reader.onerror = (event) => {
                        this.set({
                            scriptUpload: undefined,
                            uploadError: event.target.error
                        });
                    };
                    reader.readAsText(file);
                }
            },
            onScriptClone(event, script) {
                event.preventDefault();

                this.set({
                    scriptEdit: JSON.parse(JSON.stringify(script)),
                    editOverwrite: undefined
                });
                $(this.refs.tabs).find('.item').tab('change tab', 'edit');
            },
            onScriptEdit(event, script) {
                event.preventDefault();

                this.set({
                    scriptEdit: JSON.parse(JSON.stringify(script)),
                    editOverwrite: script
                });
                $(this.refs.tabs).find('.item').tab('change tab', 'edit');
            },
            onEditSave({ script: scriptEdit }) {
                const editOverwrite = this.get('editOverwrite');
                const scripts = this.get('scripts');
                const scriptSelect = this.get('scriptSelect');

                scriptEdit.stamp = (new Date()).toISOString();

                if (editOverwrite) {
                    for (const [k,v] of Object.entries(scriptEdit)) {
                        editOverwrite[k] = v;
                    }

                    this.set({
                        scripts,
                        scriptSelect,
                        scriptEdit
                    });
                }
                else {
                    scripts.push(scriptEdit);
                    this.set({
                        scripts,
                        scriptSelect: scriptEdit,
                        scriptEdit,
                        editOverwrite: scriptEdit
                    })
                }
            },
            onEditClone({ script: scriptEdit }) {
                this.set({
                    scriptEdit: JSON.parse(JSON.stringify(scriptEdit)),
                   editOverwrite: undefined
                });
            },
            onEditNew({ script: scriptEdit }) {
                this.set({
                    scriptEdit: {
                        name: '',
                        description: '',
                        stamp: (new Date()).toISOString(),
                        author: ''
                    },
                    editOverwrite: undefined
                });
            },
            onEditDelete({ script: scriptEdit }) {
                const scripts = this.get('scripts');
                const editOverwrite = this.get('editOverwrite');

                this.set({
                    scripts: scripts.filter(s => s !== editOverwrite),
                    scriptEdit: {
                        name: '',
                        description: '',
                        stamp: (new Date()).toISOString(),
                        author: ''
                    },
                    editOverwrite: undefined
                })
            }

        },
        events: {
        },
        components: {
            ScriptCard,
            ScriptEdit
        }
    };
</script>